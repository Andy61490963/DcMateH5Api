name: Deploy DcMateH5Api to IIS (Self-hosted)

on:
  workflow_dispatch: {}
  push:
    branches: [ "main" ]

env:
  PROJECT_PATH: "DcMateH5Api.csproj"
  DEPLOY_ROOT: "C:\\CICDDeploy"
  PUBLISH_DIR: "C:\\CICDDeploy\\publish"
  IIS_PHYSICAL_PATH: "C:\\inetpub\\wwwroot\\測試"
  IIS_APP_POOL: "DcMateH5Api"

jobs:
  deploy:
    runs-on: [self-hosted, Windows, iis, dcmate]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure folders
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          foreach ($p in @($env:DEPLOY_ROOT, $env:PUBLISH_DIR, $env:IIS_PHYSICAL_PATH)) {
            if (!(Test-Path $p)) { New-Item -ItemType Directory -Path $p | Out-Null }
          }
          Write-Host "PUBLISH_DIR: $env:PUBLISH_DIR"
          Write-Host "IIS_PATH   : $env:IIS_PHYSICAL_PATH"

      - name: Publish (Release)
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'

          dotnet --info
          dotnet restore "$env:PROJECT_PATH"
          dotnet build "$env:PROJECT_PATH" -c Release --no-restore

          Remove-Item "$env:PUBLISH_DIR\*" -Recurse -Force -ErrorAction SilentlyContinue
          dotnet publish "$env:PROJECT_PATH" -c Release -o "$env:PUBLISH_DIR" --no-build

          if (!(Test-Path "$env:PUBLISH_DIR")) {
            throw "Publish folder not found: $env:PUBLISH_DIR"
          }

      - name: Deploy to IIS
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Import-Module WebAdministration -ErrorAction Stop

          $publish = $env:PUBLISH_DIR
          $target  = $env:IIS_PHYSICAL_PATH
          $pool    = $env:IIS_APP_POOL
          $offline = Join-Path $target "app_offline.htm"

          if (!(Test-Path $target)) { New-Item -ItemType Directory -Path $target | Out-Null }

          try {
            # 1) 下線：擋站 + 觸發 IIS 卸載
            "Deploying... Please wait." | Out-File -FilePath $offline -Encoding utf8 -Force

            # 2) 停 AppPool（已停止也不要炸）
            Stop-WebAppPool -Name $pool -ErrorAction SilentlyContinue | Out-Null

            # 3) 只殺「此 AppPool」的 w3wp（IIS 官方方式拿 PID）
            $pids = @()
            try {
              $state = Get-WebAppPoolState -Name $pool -ErrorAction Stop
              if ($null -ne $state.WorkerProcesses) {
                $pids = $state.WorkerProcesses | Select-Object -ExpandProperty ProcessId
              }
            } catch {
              # 有些環境 Get-WebAppPoolState 拿不到 WorkerProcesses，就走 IIS:\AppPools 方式
              try {
                $appPoolItem = Get-Item "IIS:\AppPools\$pool" -ErrorAction Stop
                if ($null -ne $appPoolItem.WorkerProcesses) {
                  $pids = $appPoolItem.WorkerProcesses | Select-Object -ExpandProperty ProcessId
                }
              } catch {
                Write-Host "Could not resolve worker process PIDs for app pool: $pool"
              }
            }

            foreach ($pid in $pids) {
              Write-Host "Killing w3wp pid=$pid for pool=$pool"
              Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue
            }

            # 4) 同步檔案（保留 SecurityKeys，不要被 /MIR 清掉）
            robocopy "$publish" "$target" /MIR /R:5 /W:1 /NFL /NDL /NP /XF "*.pdb" /XD "SecurityKeys"
            $rc = $LASTEXITCODE
            if ($rc -ge 8) { throw "Robocopy failed. ExitCode=$rc" }

            # Robocopy 1~7 代表有差異/有複製，GitHub Actions 會當成失敗，所以歸零
            $global:LASTEXITCODE = 0

            # 5) 上線
            Remove-Item $offline -Force -ErrorAction SilentlyContinue
            Start-WebAppPool -Name $pool -ErrorAction SilentlyContinue | Out-Null

            Write-Host "Deploy done."
          }
          finally {
            # 失敗也不要卡 offline
            Remove-Item $offline -Force -ErrorAction SilentlyContinue
          }
